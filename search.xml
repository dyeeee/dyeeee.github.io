<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客导览</title>
    <url>/2021/02/23/%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%A7%88/</url>
    <content><![CDATA[<p>导览</p>]]></content>
  </entry>
  <entry>
    <title>SwiftUI手动设置软件深色模式/自动跟随系统外观</title>
    <url>/2021/02/06/SwiftUI%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AE%E8%BD%AF%E4%BB%B6%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F-%E8%87%AA%E5%8A%A8%E8%B7%9F%E9%9A%8F%E7%B3%BB%E7%BB%9F%E5%A4%96%E8%A7%82/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SwiftUI</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI2.0 ScrollViewReader用法</title>
    <url>/2021/01/12/SwiftUI2-0-ScrollViewReader%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SwiftUI</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>英英/英汉词典资源整合</title>
    <url>/2021/01/07/%E8%8B%B1%E8%8B%B1-%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<blockquote><p>整合一份英英/英汉词典资源，包含单词、音标、英英释义、英汉释义、例句等内容。可用于本地词典、背单词软件等的开发。在此记录资源来源及字段含义。</p><blockquote></blockquote><p>GitHub链接：<a href="https://github.com/dyeeee/English-Chinese-Dictionary.git" target="_blank" rel="noopener">English-Chinese-Dictionary</a></p></blockquote><a id="more"></a><h3 id="0-参考来源"><a href="#0-参考来源" class="headerlink" title="0. 参考来源"></a>0. 参考来源</h3><ol><li>GitHub项目 <a href="https://github.com/skywind3000/ECDICT" target="_blank" rel="noopener">ECDICT</a>, 收集了数十万单词的词典数据库，2.4k Star。</li><li>CSDN <a href="https://u25th-engineer.blog.csdn.net/article/details/105901529?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param" target="_blank" rel="noopener">爬取并处理150708个英语单词的例句</a>，博主自行爬取了单词的注音、释义、例句。</li></ol><h3 id="1-整理及合并"><a href="#1-整理及合并" class="headerlink" title="1. 整理及合并"></a>1. 整理及合并</h3><p>ECDICT项目内容非常的丰富，后续的资料整合都是以该项目的资料作为基础。该项目最近更新时间已超过一年前，其中部分数据字段如detail，audio等后续暂未添加，因此暂时删去。该数据库中的音标经对照基本为英式音标，同时没有例句资源。</p><p><a href="https://u25th-engineer.blog.csdn.net/article/details/105901529?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param" target="_blank" rel="noopener">爬取并处理150708个英语单词的例句</a>文章中，博主自行爬取了单词的注音、释义、例句，并发布了.sql文件。该数据库中的音标（含英、美）及释义字段合并为了同一个字段，使用的时候可能有所不便。通过模糊匹配提取出了ECDICT中缺乏的美式音标，并基于单词进行关联。例句资源也同样进行关联。另，为了便于导出为csv等文件格式使用，所有空值使用文本”nullTag”代替。</p><p>最终数据库包含以下字段：<br>| 字段名 | 字段说明 |<br>| —- | —- |<br>| wordID | 单词ID，主键 |<br>| wordContent | 单词 |<br>| phonetic_EN | 英式英标 |<br>| phonetic_US | 美式英标 |<br>| definition | 英英释义 |<br>| translation | 英含释义 |<br>| wordTags | 单词标记（四六级/雅思等） |<br>| wordExchanges | 时态复数等词形变换 |<br>| bncLevel | 英国国家语料库词频顺序（1为频率最高） |<br>| frqLevel | 当代语料库词频顺序（1为频率最高） |<br>| collinsLevel | 柯林斯星级（1-5星，5星为频率最高） |<br>| oxfordLevel | 是否牛津三千核心词汇 |<br>| exampleSentences | 例句 |</p><h3 id="2-字段详情"><a href="#2-字段详情" class="headerlink" title="2. 字段详情"></a>2. 字段详情</h3><ul><li><p>wordID</p><p>单词ID，主键，1-770611，无空值，无重复值</p></li><li><p>wordTags</p><p>有效字段条数：14942。14942词包含任一标签，其余为nullTag。属于多个标签则空格分隔。</p><pre><code>e.g. abandon
gk cet4 cet6 </code></pre><table><thead><tr><th>标签明细</th><th>说明</th></tr></thead><tbody><tr><td>zk</td><td>中考词汇</td></tr><tr><td>gk</td><td>高考词汇</td></tr><tr><td>ky</td><td>考研词汇</td></tr><tr><td>cet4</td><td>四级词汇</td></tr><tr><td>cet6</td><td>六级词汇</td></tr><tr><td>ielts</td><td>雅思词汇</td></tr><tr><td>toefl</td><td>托福词汇</td></tr><tr><td>gre</td><td>GRE词汇</td></tr></tbody></table></li><li><p>wordExchanges</p><p>有效字段条数：96290。96290词包含至少一个词形变化。</p><pre><code>e.g. perceive
d:perceived/p:perceived/3:perceives/i:perceiving</code></pre><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>p</td><td>过去式（did）</td></tr><tr><td>d</td><td>过去分词（done）</td></tr><tr><td>i</td><td>现在分词（doing）</td></tr><tr><td>3</td><td>第三人称单数（does）</td></tr><tr><td>r</td><td>形容词比较级（-er）</td></tr><tr><td>t</td><td>形容词最高级（-est）</td></tr><tr><td>s</td><td>名词复数形式</td></tr><tr><td>0</td><td>Lemma（词根），如 perceived 的 Lemma 是 perceive</td></tr><tr><td>1</td><td>Lemma 的变换形式，比如 s 代表 apples 是其 lemma 的复数形式</td></tr></tbody></table></li><li><p>bncLevel</p><p>有效字段条数：45443。British National Corpus，英国国家语料库词频顺序，1-45443，1为使用频率最高的单词(the)。其余单词此字段值为0。</p><blockquote><p>参考资料：</p><p><a href="http://www.kilgarriff.co.uk/bnc-readme.html" target="_blank" rel="noopener">http://www.kilgarriff.co.uk/bnc-readme.html</a><br><a href="http://www.natcorp.ox.ac.uk/using/index.xml?ID=freq" target="_blank" rel="noopener">http://www.natcorp.ox.ac.uk/using/index.xml?ID=freq</a></p><p>百度到最常见的bnc15000词与本数据库提供的有所出入，但是大致的词频趋势是一致的</p></blockquote></li><li><p>frqLevel</p><p>有效字段条数：42231。数据基于Corpus of Contemporary American English (COCA)，当代美国英语语料库，1-42231，1为使用频率最高的单词(the)。其余单词此字段值为0。</p><blockquote><p>参考资料：</p><p><a href="https://www.wordfrequency.info/files/entries.pdf" target="_blank" rel="noopener">https://www.wordfrequency.info/files/entries.pdf</a></p><p>本数据库中的数据与此来源完全一致</p></blockquote><blockquote><p>英国国家语料库词频顺序与当代美国英语语料库顺序区别：引自ECDICT源项目</p><p>BNC 词频统计的是最近几百年的历史各类英文资料，而当代语料库只统计了最近 20 年的，为什么两者都要提供呢？</p><p>很简单，quay（码头）这个词在当代语料库里拍两万以外，你可能觉得是个没必要掌握的生僻词，而 BNC 里面却排在第 8906 名，基本算是一个高频词，为啥呢？可以想象过去航海还是一个重要的交通工具，所以以往的各类文字资料对这个词提的比较多，你要看懂 19 世纪即以前的各类名著，你会发现 BNC 的词频很管用。</p><p>而你要阅读各类现代杂志，当代语料库的作用就体现出来了，比如 Taliban（塔利班），在 BNC 词频里基本就没收录（没进前 20 万词汇），而在当代语料库里，它已经冒到 6089 号了，高频中的高频。</p><p>BNC 较为全面和传统，针对性学习能帮助你阅读各类国外帝王将相的文学名著，当代语料库较为现代和实时，以和科技紧密相关。所以两者搭配，干活不累。而你要阅读各类现代杂志，当代语料库的作用就体现出来了，比如 Taliban（塔利班），在 BNC 词频里基本就没收录（没进前 20 万词汇），而在当代语料库里，它已经冒到 6089 号了，高频中的高频。</p><p>BNC 较为全面和传统，针对性学习能帮助你阅读各类国外帝王将相的文学名著，当代语料库较为现代和实时，以和科技紧密相关。所以两者搭配，干活不累。</p></blockquote></li></ul><ul><li><p>collinsLevel</p><p>有效字段条数：13633。数据基于Collins COBUILD Advanced Learner’s English-Chinese Dictionary，柯林斯词典。分为1-5级，级别5为最常使用，级别1为较少使用。共13633词有级别，其余单词此字段值为0。</p><blockquote><p>参考资料：</p><p><a href="https://inli.neocities.org/Collins%20COBUILD%20English%20Dictionary%20FREQUENT%20WORD%20LIST.pdf" target="_blank" rel="noopener">https://inli.neocities.org/Collins%20COBUILD%20English%20Dictionary%20FREQUENT%20WORD%20LIST.pdf</a></p><p>2010版柯林斯星级词汇，本数据库中的数据与此来源不完全一致，但大致相同</p></blockquote></li><li><p>oxfordLevel</p><p>有效字段条数：3461。数据基于Oxford English Corpus，是一份从包含20亿词的牛津英语语料库（Oxford English Corpus）中精选而出的英语学习者必备常用 3000 词表。若为核心词汇则为1，3461词，其余单词此字段值为0。</p><blockquote><p>参考资料：</p><p><a href="https://www.oxfordlearnersdictionaries.com/wordlists/oxford3000-5000" target="_blank" rel="noopener">https://www.oxfordlearnersdictionaries.com/wordlists/oxford3000-5000</a></p></blockquote></li><li><p>exampleSentences</p><p>有效字段条数：95675。爬取自必应词典，共95675词有例句，每条例句包含中英对照，用<code>&lt;br&gt;</code>隔开</p><pre><code>e.g. abandon
Later, as a result of working reason and the matter that oneself study, abandon for a long time without time.&lt;br&gt;后来，由于工作的原因和自己学习的原因，没有时间放弃很长时间了。&lt;br&gt;Through repeated failures a man learns to persist in the pursuit of worthy goals and to abandon goals that are unworthy of him.&lt;br&gt;通过不断的失败，真正的男人会学会如何坚持追求真正有价值的东西，放弃没有价值的追求。</code></pre></li></ul><h3 id="3-提取特定词典"><a href="#3-提取特定词典" class="headerlink" title="3. 提取特定词典"></a>3. 提取特定词典</h3><p>完整数据库导出为csv后270MB+，为了使用方便，也提取几个较小的词典。</p><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>Complete_Dictionary.7z</td><td>完整词典的压缩包，解压后约270M</td></tr><tr><td>Common_Words.csv</td><td>常用词（有单词标记/属于柯林斯星级词/属于牛津核心词/BNC频率前10000/当代美国英语语料频率前10000），共2w条</td></tr><tr><td>CET_Words.csv</td><td>tag包含cet4/cet6的单词</td></tr><tr><td>IELTS_Words.csv</td><td>tag包含ielts的单词</td></tr><tr><td>Complete_Dictionary_1Sentence.csv</td><td>全数据集，但仅包含1条例句</td></tr><tr><td>Complete_Dictionary_3Sentences.csv</td><td>全数据集，但仅包含3条例句</td></tr></tbody></table>]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo迁移记录</title>
    <url>/2020/12/29/Blog-transport-test/</url>
    <content><![CDATA[<p>macOS系统重装，迁移整个博客文件夹，记录重装node.js, 重装hexo流程，测试部署情况。</p><p>hexo文件夹内容、配置文件不变，迁移后部署配置保留不变，安装node.js，安装git，通过npm安装hexo。</p><blockquote><p>node版本直接官网下载安装的话过高，无法hexo d部署网站，通过nvm来控制node版本后成功恢复部署</p></blockquote><a id="more"></a><h4 id="卸载node-js"><a href="#卸载node-js" class="headerlink" title="卸载node.js"></a>卸载node.js</h4><p>依次在终端执行下面的脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall npm -g</span><br><span class="line">sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*</span><br><span class="line">sudo rm -rf /usr/local/include/node /Users/$USER/.npm</span><br><span class="line">sudo rm /usr/local/bin/node</span><br><span class="line">sudo rm /usr/local/share/man/man1/node.1</span><br><span class="line">sudo rm /usr/local/lib/dtrace/node.d</span><br></pre></td></tr></table></figure><p>验证结果,终端输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node </span></span><br><span class="line">//command not found</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm </span></span><br><span class="line">//command not found</span><br></pre></td></tr></table></figure><h4 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h4><p>官网下载安装包 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p>安装完成后查看版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br></pre></td></tr></table></figure><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>macOS 内置git，查看版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo</span></span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>此时可以正常使用hexo new “Blog transport test”, hexo g, 并hexo s在本地启动服务，但是hexo d部署时出错。百度原因为node版本过高，安装低版本nodejs或者使用nvm管理node版本</p><blockquote><p>nvm是node版本管理工具，为了解决node各种版本存在不兼容现象，nvm可以在同一台机器上安装和切换不同版本的node。</p></blockquote><h4 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h4><p>先安装homebrew</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”</span><br></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew -v</span></span><br></pre></td></tr></table></figure><h5 id="再次卸载node"><a href="#再次卸载node" class="headerlink" title="再次卸载node"></a>再次卸载node</h5><h5 id="brew-安装nvm"><a href="#brew-安装nvm" class="headerlink" title="brew 安装nvm"></a>brew 安装nvm</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install nvm</span></span><br></pre></td></tr></table></figure><p>安装完成后打开配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim .bash_profile</span></span><br></pre></td></tr></table></figure><p>按 i 进入编辑模式<br>在文件里添加以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> NVM_DIR=~/.nvm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> $(brew --prefix nvm)/nvm.sh</span></span><br></pre></td></tr></table></figure><p>esc退出编辑模式, :wq保存, 重新source</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> .bash_profile</span></span><br></pre></td></tr></table></figure><h5 id="nvm本地配置问题"><a href="#nvm本地配置问题" class="headerlink" title="nvm本地配置问题"></a>nvm本地配置问题</h5><p>.bash_profile中配置后nvm命令没有永久生效（JAVA和Homebrew的可以？），原因为macOS 10.15后使用zsh，需要在 ～/.zshrc 最后添加一句source .bash_profile即可。（但是这样每次启动终端都略慢，待解决）</p><h5 id="通过nvm安装指定版本的node"><a href="#通过nvm安装指定版本的node" class="headerlink" title="通过nvm安装指定版本的node"></a>通过nvm安装指定版本的node</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nvm install 12.2</span></span><br></pre></td></tr></table></figure><p>使用指定版本的node</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nvm use 12.2</span></span><br></pre></td></tr></table></figure><p>设置默认版本的Node，每次启动终端都使用该版本的node</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nvm <span class="built_in">alias</span> default 12.2</span></span><br></pre></td></tr></table></figure><h4 id="重新部署hexo成功"><a href="#重新部署hexo成功" class="headerlink" title="重新部署hexo成功"></a>重新部署hexo成功</h4><p>配置文件等内容都不变，迁移hexo文件夹完成</p>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的常用操作</title>
    <url>/2020/09/29/hexo%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote><p>用hexo记录一下hexo常用的操作和命令</p></blockquote><a id="more"></a><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="压缩资源优化性能以及懒加载"><a href="#压缩资源优化性能以及懒加载" class="headerlink" title="压缩资源优化性能以及懒加载"></a>压缩资源优化性能以及懒加载</h4><p><a href="https://blog.csdn.net/Aoman_Hao/article/details/87917671" target="_blank" rel="noopener">https://blog.csdn.net/Aoman_Hao/article/details/87917671</a></p><h4 id="字数统计的关闭"><a href="#字数统计的关闭" class="headerlink" title="字数统计的关闭"></a>字数统计的关闭</h4><p>想要为部分文章开启/关闭字数统计，但是主题全局开启在post中设置没用。</p><p>解决方法：<br>在post.swig中，出现字数统计的代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.post_wordcount.wordcount or theme.post_wordcount.min2read %&#125;</span><br></pre></td></tr></table></figure><p>借助文章的属性comments来控制开关，如果关闭comments则关闭字数统计</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if (theme.post_wordcount.wordcount or theme.post_wordcount.min2read) and (post.comments) %&#125;</span><br></pre></td></tr></table></figure><h5 id="补充，添加文章属性的方法-https-www-jianshu-com-p-79fe9fb9dfa0"><a href="#补充，添加文章属性的方法-https-www-jianshu-com-p-79fe9fb9dfa0" class="headerlink" title="补充，添加文章属性的方法 https://www.jianshu.com/p/79fe9fb9dfa0"></a>补充，添加文章属性的方法 <a href="https://www.jianshu.com/p/79fe9fb9dfa0" target="_blank" rel="noopener">https://www.jianshu.com/p/79fe9fb9dfa0</a></h5><p>可以直接添加一个属性:false来控制</p><h4 id="对手机的适配"><a href="#对手机的适配" class="headerlink" title="对手机的适配"></a>对手机的适配</h4><p>在手机上的页面，由于post的边框过宽，总感觉显示的内容太少了，找到源码是在themes/next/source/css/_common/components/post/post-expand.styl中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media (max-width: 800px) &#123;</span><br></pre></td></tr></table></figure><p>是对屏幕宽度小于800px的设备进行的设置，在这里把margin进行设置，减小手机浏览左右的宽度</p><h4 id="文章间距的设置"><a href="#文章间距的设置" class="headerlink" title="文章间距的设置"></a>文章间距的设置</h4><p>hexo文章的布局为 title -&gt; meta -&gt; body</p><p>在/themes/next/source/css/_custom/custom.styl中添加下面的代码来控制间距：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//文章预览正文的顶部与标题行的默认间距</span><br><span class="line">.posts-expand .post-meta &#123;</span><br><span class="line">	margin: 0px 0 10px 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.posts-expand .post-title &#123;</span><br><span class="line">	margin: 10px 0 0px 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贴上美化相关的文章"><a href="#贴上美化相关的文章" class="headerlink" title="贴上美化相关的文章"></a>贴上美化相关的文章</h3><p>hexo + next主题高级配置<br><a href="https://www.jianshu.com/p/344cf061598d" target="_blank" rel="noopener">https://www.jianshu.com/p/344cf061598d</a></p><p>缩小首页文章列表间距并增加阴影效果<br><a href="https://www.jianshu.com/p/38c14db02c8b?utm_campaign=maleskine" target="_blank" rel="noopener">https://www.jianshu.com/p/38c14db02c8b?utm_campaign=maleskine</a></p><p>适配手机的css<br><a href="https://my.oschina.net/u/4346667/blog/3593303" target="_blank" rel="noopener">https://my.oschina.net/u/4346667/blog/3593303</a></p><p>文章置顶以及置顶标记<br><a href="http://www.itfanr.cc/2017/12/06/hexo-blog-optimization/" target="_blank" rel="noopener">http://www.itfanr.cc/2017/12/06/hexo-blog-optimization/</a></p><p>添加相册（待添加） <a href="https://jygzyc.github.io/photos/" target="_blank" rel="noopener">https://jygzyc.github.io/photos/</a> 作者：jygzyc； <a href="https://hasaik.com/posts/39d47c89.html" target="_blank" rel="noopener">https://hasaik.com/posts/39d47c89.html</a></p><p>sidebar内容扩展 <a href="https://www.izhongxia.com/posts/22240.html" target="_blank" rel="noopener">https://www.izhongxia.com/posts/22240.html</a></p><h3 id="1-文章"><a href="#1-文章" class="headerlink" title="1. 文章"></a>1. 文章</h3><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p>在hexo文件夹下进入控制台，输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &apos;title标题&apos;</span><br></pre></td></tr></table></figure><p>新建文章后会在<code>hexo文件夹/source/_post</code>路径下创建title.md和title文件夹。.md文件即为文章内容，配置了添加图片后可以在文件夹中放入图片，在.md中插入图片。</p><hr><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![figName](文章文件夹名/图片名.JPG &apos;&apos;figPreview&apos;&apos;)</span><br><span class="line"></span><br><span class="line">figName: 显示在图片下面的文字</span><br><span class="line">figPreview: 是图片的标题，当鼠标移到图片上时显示的内容</span><br></pre></td></tr></table></figure><hr><h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h4><p>文章的头格式如下:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Title</span><br><span class="line">date: 2020-05-27 17:33:48</span><br><span class="line">categories: </span><br><span class="line">    - cate1</span><br><span class="line">    - cate2</span><br><span class="line">tags:</span><br><span class="line">    - tag1</span><br><span class="line">    - tag2</span><br><span class="line">comments: false</span><br><span class="line">description: 🔝 //自动成为预览内容，不用使用more标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/e17711e44e00" target="_blank" rel="noopener">配置categories和tags</a>之后，在文章头部添加对应的分类和标签。</p><h5 id="hide标签"><a href="#hide标签" class="headerlink" title="hide标签"></a>hide标签</h5><p>配置了隐藏文章后，添加<br><code>- hide</code><br>标签可以让文章隐藏。</p><hr><h4 id="关闭评论"><a href="#关闭评论" class="headerlink" title="关闭评论"></a>关闭评论</h4><p>如需取消某个 页面/文章 的评论，在 md 文件的 front-matter 中增加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comments: false</span><br></pre></td></tr></table></figure><hr><h4 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h4><p>在source/_post路径下删除对应为文章标题和文件夹，然后进行一次生成和部署</p><hr><h4 id="文章预览"><a href="#文章预览" class="headerlink" title="文章预览"></a>文章预览</h4><p>在文章中添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo网页只显示预览之前的内容</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">#### 代码及代码块</span><br><span class="line">在markdown中使用``包围一段代码呈现代码效果 </span><br><span class="line">`print(&quot;hi&quot;)`,</span><br><span class="line">使用一组```包围一段代码呈现代码块</span><br><span class="line"></span><br><span class="line">    ```swift</span><br><span class="line">    var A:String = &quot;hi&quot;</span><br><span class="line">    print(A)</span><br></pre></td></tr></table></figure><p>在开头的```后声明语言，则会呈现对应的高亮显示效果：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">A</span>:<span class="type">String</span> = <span class="string">"hi"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">A</span>)</span><br></pre></td></tr></table></figure><h4 id="加粗-斜体-下划线-删除线"><a href="#加粗-斜体-下划线-删除线" class="headerlink" title="加粗/斜体/下划线/删除线"></a>加粗/斜体/下划线/删除线</h4><ul><li><p>加粗 <code>**hello**</code>, <strong>hello</strong></p></li><li><p>斜体 <code>*hello*</code>, <em>hello</em></p></li><li><p>下划线(无原生md语法) <code>&lt;u&gt;hello&lt;/u&gt;</code>, <u>hello</u></p></li><li><p>删除线 <code>~~hello~~</code>, <del>hello</del></p></li><li><p>组合 <code>***&lt;u&gt;~~hello~~&lt;/u&gt;***</code>, <strong>*<u><del>hello</del></u>*</strong></p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|  表头1  | 表头2  |</span><br><span class="line">|  -  | - |</span><br><span class="line">|  A1  | B1  |</span><br><span class="line">|  A2  | B2  |</span><br></pre></td></tr></table></figure><p>显示效果</p><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>A1</td><td>B1</td></tr><tr><td>A2</td><td>B2</td></tr></tbody></table></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对齐设置</span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-    | -:    |  :-:   |</span><br><span class="line">| 内容 | 内容 | 内容 |</span><br><span class="line">| 内容 | 内容 | 内容 |</span><br></pre></td></tr></table></figure><p>显示效果<br>| 左对齐 | 右对齐 | 居中对齐 |<br>| :-| -: | :-: |<br>| 内容 | 内容 | 内容 |<br>| 内容 | 内容 | 内容 |</p><hr><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><h4 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h4><p>创建文章后生成静态文件，此时可以在本地服务器预览：</p><p><code>hexo generate</code> ，可以简写为 <code>hexo g</code></p><p>添加<code>-d</code>生成后直接部署网站</p><hr><h4 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h4><p>生成静态文件后，需要部署才能在网站上预览：</p><p><code>hexo deploy</code> ，可以简写为 <code>hexo d</code></p><hr><h4 id="打开本地服务器"><a href="#打开本地服务器" class="headerlink" title="打开本地服务器"></a>打开本地服务器</h4><p>目前这个hexo同时部署在CODING和GitHub上，但是如果遇到ssl证书过期问题或者网络问题导致部署延迟的话，可以在本地服务器上预览网站：</p><p><code>hexo server</code> ，可以简写为 <code>hexo s</code></p><hr><h4 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h4><p>短期内进行了多次修改、静态页生成失败、部署失败等问题，可以尝试先清除一下缓存：</p><p><code>hexo clean</code></p><hr><h3 id="后续遇到需要记录的操作再更新"><a href="#后续遇到需要记录的操作再更新" class="headerlink" title="后续遇到需要记录的操作再更新"></a>后续遇到需要记录的操作再更新</h3><blockquote><p>参考自<br><a href="https://www.cnblogs.com/wsmrzx/p/9439448.html" target="_blank" rel="noopener">Hexo系列(三) 常用命令详解</a></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(hello)</span><br><span class="line">select * from</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>figtest</title>
    <url>/2020/05/27/figtest/</url>
    <content><![CDATA[<p><img src="/2020/05/27/figtest/123.JPG" alt="app"></p>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化程序设计19-29章复习</title>
    <url>/2019/12/15/%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A119-29%E7%AB%A0%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<hr><blockquote><p>可视化程序设计8-15章问答题（中文影印版15-21章）<br>基于 <em>Software Engineering A PRACTITIONER’S APPROACH 8th</em> <em>软件工程：实践者的研究方法</em></p></blockquote><hr><ul><li><strong>PART 3 质量管理 QUALITY MANAGEMENT</strong></li></ul><ol><li><a href="#19">CH19 质量概念</a></li><li><a href="#21">CH21 软件质量保证</a></li><li><a href="#22">CH22 软件测试策略</a></li><li><a href="#23">CH23 测试传统的应用软件</a></li><li><a href="#24">CH24 测试面向对象的应用</a></li><li><a href="#27">CH27 安全性工程</a></li><li><a href="#29">CH29 软件配置管理</a></li></ol><hr><a id="more"></a><h2 id="CHAPTER-19-Quality-Concepts-质量概念"><a href="#CHAPTER-19-Quality-Concepts-质量概念" class="headerlink" title="CHAPTER 19 Quality Concepts 质量概念"></a><span id="19">CHAPTER 19 Quality Concepts 质量概念</span></h2><ol><li>What are three dimensions of software quality?<br>软件质量的三个方面是什么？<br>Answer (Section 19.2):</li></ol><ul><li>An effective software process establishes the infrastructure that supports any effort at building a high quality software product.</li><li>A useful product delivers the content, functions, and features that the end-user desires, but as important, it delivers these assets in a reliable, error free way.</li><li>By adding value for both the producer and user of a software product, high quality software provides benefits for the software organization and the end-user community.</li><li>有效的软件流程可以建立基础架构，以支持构建高质量软件产品的所有工作。</li><li>有用的产品可以提供最终用户所需的内容，功能和特性，但同样重要的是，它可以可靠，无错误的方式提供这些资产。</li><li>通过为软件产品的生产者和用户增加价值，高质量的软件为软件组织和最终用户社区带来了好处。<br></li></ul><ol start="2"><li>Describe the costs associated with software quality work?<br>描述与软件质量工作相关的成本？<br>Answer (Section 19.3.2):</li></ol><ul><li><p>Prevention costs - quality planning, formal technical reviews, test equipment, training</p></li><li><p>Appraisal costs - in-process and inter-process inspection, equipment calibration and maintenance, testing</p></li><li><p>Internal failure costs - rework, repair, failure mode analysis</p></li><li><p>External failure costs - complaint resolution, product return and replacement, help line support, warranty work</p></li><li><p>预防费用-质量计划，正式技术审查，测试设备，培训</p></li><li><p>评估费用-过程中和过程间检查，设备校准和维护，测试</p></li><li><p>内部故障成本-返工，维修，故障模式分析</p></li><li><p>外部故障成本-解决投诉，产品退回和更换，热线支持，保修工作</p><br></li></ul><ol start="3"><li>What practices should software engineers follow to enhance the quality of software produced by their team?<br>软件工程师应遵循哪些实践来提高其团队生产的软件的质量？<br>Answer (Section 19.4):</li></ol><ul><li>Software quality is the result of good project management and solid engineering practice</li><li>To build high quality software you must understand the problem to be solved and be capable of creating a quality design the conforms to the problem requirements</li><li>Eliminating architectural flaws during design can improve quality</li><li>软件质量是良好的项目管理和扎实的工程实践的结果</li><li>要构建高质量的软件，您必须了解要解决的问题并能够创建符合问题要求的质量设计</li><li>在设计过程中消除架构缺陷可以提高质量<br></li></ul><ol start="4"><li>Discuss how poor management decisions can impact software quality?<br>讨论糟糕的管理决策如何影响软件质量？<br>Answer (Section 19.3.6):</li></ol><ul><li>Estimation decisions – irrational delivery date estimates cause teams to take short-cuts that can lead to reduced product quality</li><li>Scheduling decisions – failing to pay attention to task dependencies when creating the project schedule may force the project team to test modules without their subcomponents and quality may suffer</li><li>Risk-oriented decisions – reacting to each crisis as it arises rather than building in mechanisms to monitor risks and having established contingency plans may result in products having reduced quality</li><li>估算决策–不合理的交货日期估算会导致团队采取捷径，从而导致产品质量下降</li><li>计划决策–在创建项目进度表时未注意任务依赖性可能会迫使项目团队测试没有子组件的模块，从而可能会降低质量</li><li>以风险为导向的决策–对每次危机进行应对，而不是建立监视风险的机制，并且已建立应急计划可能会导致产品质量下降<br></li></ul><h2 id="CHAPTER-21-Software-Quality-Assurance-软件质量保证"><a href="#CHAPTER-21-Software-Quality-Assurance-软件质量保证" class="headerlink" title="CHAPTER 21 Software Quality Assurance 软件质量保证"></a><span id="21">CHAPTER 21 Software Quality Assurance 软件质量保证</span></h2><ol><li>List the tasks performed by the SQA group.<br>列出SQA组执行的任务。<br>Answer (Section 21.4.1):</li></ol><ul><li>Prepare SQA plan for the project.</li><li>Participate in the development of the project’s software process description.</li><li>Review software engineering activities to verify compliance with the defined software process.</li><li>Audit designated software work products to verify compliance with those defined as part of the software process.</li><li>Ensure that any deviations in software or work products are documented and handled according to a documented procedure.</li><li>Record any evidence of noncompliance and reports them to management</li><li>为项目准备SQA计划。</li><li>参与开发项目的软件过程描述。</li><li>审查软件工程活动，以验证是否符合定义的软件过程。</li><li>审核指定的软件工作产品，以验证是否符合在软件过程中定义的产品。</li><li>确保按照书面程序记录和处理软件或工作产品中的任何偏差。</li><li>记录任何不合规的证据并将其报告给管理层<br></li></ul><ol start="2"><li>What are the goals for the project SQA activities?<br>项目SQA活动的目标是什么？<br>Answer (Section 21.4.2):</li></ol><ul><li>Requirements quality</li><li>Design quality</li><li>Code quality</li><li>Quality control effectiveness</li><li>需求质量</li><li>设计品质</li><li>代码质量</li><li>质量控制有效性<br></li></ul><ol start="3"><li><p>What is meant by the term software reliability?<br>软件可靠性一词是什么意思？<br>Answer (Section 21.7):<br>Software reliability is the probability of error free operation of a computer program in a specified environment for a specified time period.<br>软件可靠性是指在指定的环境中指定的时间段内计算机程序无错误运行的概率。</p></li><li><p>Describe statistical quality assurance?<br>描述统计质量保证？<br>Answer (Section 21.6):</p></li></ol><ul><li>Information about</li><li>software defects is collected and categorized</li><li>Each defect is traced back to its cause</li><li>Using the Pareto principle (80% of the defects can be traced to 20% of the causes) isolate the “vital few” defect causes</li><li>Move to correct the problems that caused the defects in the “vital few”</li><li>相关信息</li><li>收集软件缺陷并进行分类</li><li>每个缺陷都可以追溯到其原因</li><li>使用帕累托原理（可以将80％的缺陷追溯到20％的原因），将“很少的”缺陷原因隔离出来</li><li>纠正导致“少数几个”缺陷的问题<br></li></ul><h2 id="CHAPTER-22-Software-Testing-Strategies-软件测试策略"><a href="#CHAPTER-22-Software-Testing-Strategies-软件测试策略" class="headerlink" title="CHAPTER 22 Software Testing Strategies 软件测试策略"></a><span id="22">CHAPTER 22 Software Testing Strategies 软件测试策略</span></h2><ol><li><p>Why is regression testing an important part of any integration testing procedure?<br>为什么回归测试是任何集成测试程序的重要组成部分？<br>Answer (Section 22.3.2):<br>The goal of integration testing is to make sure that independent modules that work correctly on their own do not interfere with one another when added to the same program (unforeseen side effects are always possible). Regression testing checks for defects propagated to other modules by changes made to an existing program.<br>集成测试的目的是确保将独立正常工作的独立模块添加到同一程序时不会互相干扰（总是可能发生无法预料的副作用）。回归测试检查通过对现有程序所做的更改传播到其他模块的缺陷。</p></li><li><p>Describe object-oriented unit testing.<br>描述面向对象的单元测试。<br>Answer (Section 22.4.1):<br>Class testing for OO software is equivalent to unit testing for conventional software. The focus throughout is on designing and testing appropriate sequences of operations to exercise all class states. It makes little sense to test operations or algorithms individually for classes.<br>面向对象软件的类测试等效于常规软件的单元测试。整个过程的重点是设计和测试适当的操作顺序以行使所有课堂状态。单独测试类的操作或算法几乎没有意义。</p></li><li><p>List four types of systems tests.<br>列出四种类型的系统测试。<br>Answer (Section 22.8):</p></li></ol><ul><li>Recovery testing</li><li>Security testing</li><li>Stress testing</li><li>Performance testing</li><li>恢复测试</li><li>安全测试</li><li>压力测试</li><li>性能测试<br></li></ul><ol start="4"><li>What are the key differences between validation testing goals and acceptance testing goals?<br>验证测试目标和验收测试目标之间的主要区别是什么？<br>Answer (Section 22.7):<br>In validation testing, the test team seeks to ensure that each software function or performance characteristic conforms to its specification. In acceptance testing, the test team needs to ensure that the software works correctly for the intended user in his or her normal work environment.<br>在验证测试中，测试团队试图确保每个软件功能或性能特征均符合其规格。在验收测试中，测试团队需要确保软件可以在目标用户的正常工作环境中正常工作。</li></ol><h2 id="CHAPTER-23-Testing-Conventional-Applications-测试传统应用软件"><a href="#CHAPTER-23-Testing-Conventional-Applications-测试传统应用软件" class="headerlink" title="CHAPTER 23 Testing Conventional Applications 测试传统应用软件"></a><span id="23">CHAPTER 23 Testing Conventional Applications 测试传统应用软件</span></h2><ol><li>What are the attributes of a good software test?<br>好的软件测试的特征是什么？<br>Answer (Section 23.1):</li></ol><ul><li>Has a high probability of finding an error</li><li>Not redundant</li><li>Should be capable of uncovering a whole class of errors</li><li>Should not be too simple or too complex</li><li>发现错误的可能性很高</li><li>不多余</li><li>应该能够发现一整类错误</li><li>不应太简单或太复杂<br></li></ul><ol start="2"><li><p>Describe the differences between black-box testing and white-box testing.<br>描述黑盒测试和白盒测试之间的区别。<br>Answer (Section 23.2):<br>Black-box testing involves testing the functionality of a software component without knowing the details of its internal logic. White-box testing involves testing the independent logic paths with full implementation knowledge.<br>黑盒测试涉及在不知道其内部逻辑细节的情况下测试软件组件的功能。白盒测试涉及使用完整的实现知识来测试独立的逻辑路径。</p></li><li><p>What is equivalence partitioning as it applies to software testing?<br>什么是等效分区，因为它适用于软件测试？<br>Answer (Section 23.2):<br>A black-box testing technique in which the input domain is divided into classes of equivalent data items. Test cases are derived from combinations of elements from each equivalence class. Exhaustive testing of all input domain values is not necessary.<br>一种黑盒测试技术，其中将输入域分为等效数据项的类别。测试用例来自每个等效类的元素组合。不需要对所有输入域值进行详尽的测试。</p></li><li><p>Describe three control structure testing strategies.<br>描述三种控制结构测试策略。<br>Answer (Section 23.5):</p></li></ol><ul><li><p>Condition or branch testing -uses test cases that exercise every decision statement in the program.</p></li><li><p>Data flow testing - selects test paths (definition use chains) according to the locations of variable definitions and uses in the program</p></li><li><p>Loop testing -tests focus on the validity the repetition constructs (making sure that loops start and stop when they are supposed to)</p></li><li><p>条件或分支测试-使用执行该程序中每个决策语句的测试用例。</p></li><li><p>数据流测试-根据变量定义和程序中使用的位置选择测试路径（定义使用链）</p></li><li><p>循环测试-测试着眼于重复构造的有效性（确保循环在应有的情况下开始和停止）</p></li></ul><h2 id="CHAPTER-24-Testing-Object-Oriented-Applications-测试面向对象应用软件"><a href="#CHAPTER-24-Testing-Object-Oriented-Applications-测试面向对象应用软件" class="headerlink" title="CHAPTER 24 Testing Object-Oriented Applications 测试面向对象应用软件"></a><span id="24">CHAPTER 24 Testing Object-Oriented Applications 测试面向对象应用软件</span></h2><ol><li><p>How does unit testing differ for object-oriented testing as compared to conventional software unit testing?<br>与传统的软件单元测试相比，面向对象测试的单元测试有何不同？<br>Answer (Section 24.3.1):<br>You can no longer test a single operation in isolation (the conventional view of unit testing) but rather, as part of a class. Rather than testing an individual module, the smallest testable unit is the encapsulated class. Because a class can contain a number of different operations and a particular operation may exist as part of a number of different classes, the meaning of unit testing changes dramatically.<br>您不再可以孤立地测试单个操作（常规的单元测试视图），而可以作为类的一部分。最小的可测试单元不是测试单个模块，而是封装的类。因为一个类可以包含许多不同的操作，并且特定的操作可能作为许多不同的类的一部分而存在，所以单元测试的含义发生了巨大变化。</p></li><li><p>What is scenario-based testing?<br>什么是基于方案的测试？<br>Answer (Section 24.4.4):</p></li></ol><p>The user tasks described in the use-cases are used to construct the test cases. It is used to uncover errors that occur when actors interact with the software (focus is on user behavior, not product behavior). Generally it is better to spend more time reviewing the use cases as they are created than spending more time on testing.<br>用例中描述的用户任务用于构造测试用例。它用于发现参与者与软件交互时发生的错误（重点是用户行为，而不是产品行为）。通常，与在测试上花费更多时间相比，花更多的时间在用例创建时进行检查是更好的选择。</p><ol start="3"><li>Describe the how test cases are derived from behavior models to facilitate interclass testing?<br>描述如何从行为模型派生测试用例以促进类间测试？<br>Answer (Section 24.6.2):</li></ol><ul><li>Test cases must cover all states in the state transition diagram</li><li>Breadth first traversal of the state model can be used (test one transition at a time and only make use of previously tested transitions when testing a new transition)</li><li>Test cases can also be derived to ensure that all behaviors for the class have been adequately exercised</li><li>测试用例必须涵盖状态转换图中的所有状态</li><li>可以使用状态模型的广度优先遍历（一次测试一个转换，并且在测试新转换时仅使用先前测试的转换）</li><li>还可以派生测试用例，以确保已充分行使班级的所有行为</li></ul><ol start="4"><li>Describe three partitioning strategies that can be used when performing class level testing for OO systems.<br>描述在为OO系统执行类级别测试时可以使用的三种分区策略。<br>Answer (Section 24.5.2):</li></ol><ul><li><p>State-based partitioning - tests designed so that operations that cause state changes are tested separately from those that do not</p></li><li><p>Attribute-based partitioning - for each class attribute, operations are classified according to those that use the attribute, those that modify it, and those that do not use or modify the attribute</p></li><li><p>Category-based partitioning - operations are categorized according to the function performed: initialization, computation, query, or termination</p></li><li><p>基于状态的分区-设计测试，以使引起状态更改的操作与不进行状态更改的操作分开进行测试</p></li><li><p>基于属性的分区-对于每个类属性，根据使用该属性的操作，修改该属性的操作以及不使用或修改该属性的操作对操作进行分类</p></li><li><p>基于类别的分区-根据执行的功能对操作进行分类：初始化，计算，查询或终止</p></li></ul><h2 id="CHAPTER-27-Security-Engineering-安全性工程"><a href="#CHAPTER-27-Security-Engineering-安全性工程" class="headerlink" title="CHAPTER 27 Security Engineering 安全性工程"></a><span id="27">CHAPTER 27 Security Engineering 安全性工程</span></h2><ol><li>Which questions need to be answered in user-centered requirements elicitation?<br>在以用户为中心的需求启发中需要回答哪些问题？<br>Answer (Section 27.3.1):</li></ol><ul><li>What are the users’ security software needs?</li><li>How can a secure architecture be designed so it accommodates good user interface design?</li><li>How can satisfying user experience be designed so that it is secure?</li><li>用户的安全软件有哪些需求？</li><li>如何设计安全的体系结构以适应良好的用户界面设计？</li><li>如何设计令人满意的用户体验以确保安全？<br></li></ul><ol start="2"><li>What are the elements of a security case?<br>安全案例的要素是什么？<br>Answer (Section 27.4.1):</li></ol><ul><li>Security claims</li><li>Arguments using evidence to link claims and assumptions</li><li>Body of evidence supporting the arguments</li><li>担保要求</li><li>使用证据将主张和假设联系起来的论点</li><li>支持论点的证据<br></li></ul><ol start="3"><li><p>What is an incidence response plan?<br>什么是突发事件应对计划？<br>Answer (Section 27.6):<br>An incidence response plan spells out the actions to be carried out by each of the system’s stakeholders in response to specific security threats.<br>突发事件响应计划阐明了系统的每个利益相关者针对特定安全威胁要采取的措施。</p></li><li><p>Describe steps needs to create a threat model.<br>描述创建威胁模型所需的步骤。<br>Answer (Section 27.5):</p></li></ol><ul><li>Identify assets</li><li>Create architectural overview</li><li>Decompose application</li><li>Identify threats</li><li>Document threats</li><li>Rate threats</li><li>识别资产</li><li>创建架构概述</li><li>分解应用程序</li><li>识别威胁</li><li>文件威胁</li><li>评价威胁<br></li></ul><h2 id="CHAPTER-29-Software-Conﬁguration-Management-软件配置管理"><a href="#CHAPTER-29-Software-Conﬁguration-Management-软件配置管理" class="headerlink" title="CHAPTER 29 Software Conﬁguration Management 软件配置管理"></a><span id="29">CHAPTER 29 Software Conﬁguration Management 软件配置管理</span></h2><ol><li><p>List the 3 broad categories of information that make up the software configuration.<br>列出构成软件配置的3大类信息。<br>Answer (Section 29.1):<br>Computer programs (source code and executables), documentation (technical and user), data (internal and external to programs)<br>计算机程序（源代码和可执行文件），文档（技术和用户），数据（程序的内部和外部）</p></li><li><p>What is a software configuration audit?<br>什么是软件配置审核？<br>Answer (Section 29.3.5):<br>Once a change has been made to a software configuration item and an FTR has been conducted, the software quality team conducts its own review to ensure that software process and standards have been followed (including updating all affected documents and any other affected software configuration items).<br>一旦对软件配置项进行了更改并进行了FTR，则软件质量团队将进行自己的审查，以确保遵循了软件流程和标准（包括更新所有受影响的文档和任何其他受影响的软件配置项） 。</p></li><li><p>What is content management?<br>什么是内容管理？<br>Answer (Section 29.4.3):<br>Content management establishes a process that acquires existing content, structures it to be presented to an end-user, and provides for display, to the client-side environment.<br>内容管理建立了一个过程，该过程获取现有内容，对其进行结构化以呈现给最终用户，并提供显示给客户端环境。</p></li><li><p>Describe the change control process for a modern software development project.<br>描述现代软件开发项目的变更控制过程。<br>Answer (Section 29.3.3):<br>A change request is submitted for evaluation for a change report is submitted to the change control authority (CCA). The CCA makes the final determination as to the status and priority of the change. An engineering change order (ECO) is generated for each approved change. Items to be changes are checked out of the project database subject to its access control parameters. The modified object is subjected to SQA procedures and returned to the project database. Version control procedures are followed to produce the next version of the software. Synchronization control is used to make sure that parallel changes made by different people do not overwrite one another.<br>提交变更请求以进行评估，将变更报告提交给变更控制机构（CCA）。CCA最终确定更改的状态和优先级。将为每个批准的变更生成一个工程变更单（ECO）。根据其访问控制参数，将要更改的项目从项目数据库中检出。修改后的对象要经过SQA程序，然后返回到项目数据库。遵循版本控制过程以产生软件的下一版本。同步控制用于确保不同人员进行的并行更改不会相互覆盖。</p></li><li><p>How does software configuration management differ for Web and Mobile Apps?<br>Web和移动应用程序的软件配置管理有何不同？<br>Answer (Section 29.4)<br>The “code and go” philosophy dominates App development. So SCM for Apps must be an agile process. Documentation and review of changes is done on an as needed basis depending on the risk associated with the work products being changed.<br>“编写即用”的哲学主导着App开发。因此，SCM for Apps必须是一个敏捷的过程。根据需要，根据与更改工作产品相关的风险，对更改进行记录和审查。</p></li></ol>]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化程序设计8-15章复习</title>
    <url>/2019/12/14/%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A18-15%E7%AB%A0%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<hr><blockquote><p>可视化程序设计8-15章问答题（中文影印版7-14章）<br>基于 <em>Software Engineering A PRACTITIONER’S APPROACH 8th</em> <em>软件工程：实践者的研究方法</em></p></blockquote><hr><ul><li><strong>PART 2 建模 Modeling</strong></li></ul><ol><li><a href="#8">CH8 理解需求</a></li><li><a href="#9">CH9 需求建模：基于场景的方法</a></li><li><a href="#10">CH10 需求建模：基于类的方法</a></li><li><a href="#11">CH11 需求建模：行为和模式</a></li><li><a href="#12">CH12 设计概念</a></li><li><a href="#13">CH13 体系结构设计</a></li><li><a href="#14">CH14 设计基于类的构建</a></li><li><a href="#15">CH15 用户界面设计</a></li></ol><hr><a id="more"></a><h2 id="CHAPTER-8-Understanding-Requirements-理解需求"><a href="#CHAPTER-8-Understanding-Requirements-理解需求" class="headerlink" title="CHAPTER 8 Understanding Requirements 理解需求"></a><span id="8">CHAPTER 8 Understanding Requirements 理解需求</span></h2><ol><li><p>What are the six steps for requirements engineering?<br>需求工程的六个步骤是什么？<br>Answer (Section 8.1):<br>Inception<br>Elicitation<br>Elaboration<br>Negotiation<br>Specification<br>Requirements validation<br>起始时间<br>启发<br>细化<br>谈判<br>规格<br>需求验证</p></li><li><p>Describe the job of the requirements engineer with respect to stakeholder collaboration?<br>请描述需求工程师在利益相关者协作方面的工作吗？<br>Answer (Section 8.2.3):<br>The requirements engineer needs to identify areas of stakeholder commonality, conflict, and inconsistency on the desired needs or features.<br>需求工程师需要确定利益相关者的共同点，冲突以及在所需需求或功能上的不一致之处。</p></li><li><p>What are the benefits of using analysis patterns during the analysis modeling process?<br>在分析建模过程中使用分析模式有什么好处？<br>Answer (Section 8.5.2):<br>Patterns suggest solutions (a class, a function, or a behavior) that can be reused when modeling future applications. Analysis patterns can speed up the development of abstract analysis models by utilizing reusable models. Facilitate the transformation of the analysis model into a design model by suggesting design patterns and reliable solutions to common patterns.<br>模式建议解决方案（类，函数或行为），可以在对未来的应用程序建模时重用。通过利用可重用模型，分析模式可以加快抽象分析模型的开发。通过建议设计模式和常见模式的可靠解决方案，促进将分析模型转换为设计模型。</p></li><li><p>What work products result from the requirements engineering process?.<br>需求工程过程产生什么工作产品？<br>Answer (Section 8.1):<br>The intent of requirements engineering is to provide stakeholders with a written understanding of the problem, the work products produced include usage scenarios, function and feature lists, and requirements models<br>需求工程的目的是为利益相关者提供对问题的书面理解，所产生的工作产品包括使用场景，功能和功能列表以及需求模型</p></li></ol><h2 id="CHAPTER-9-Requirements-Modeling-Scenario-Based-Methods-需求建模：基于场景的方法"><a href="#CHAPTER-9-Requirements-Modeling-Scenario-Based-Methods-需求建模：基于场景的方法" class="headerlink" title="CHAPTER 9 Requirements Modeling: Scenario-Based Methods 需求建模：基于场景的方法"></a><span id="9">CHAPTER 9 Requirements Modeling: Scenario-Based Methods 需求建模：基于场景的方法</span></h2><ol><li><p>Describe the purposes of domain analysis.<br>描述域分析的目的。<br>Answer (Section 9.1.3):<br>Umbrella activity involving the Identification, analysis, and specification of common requirements from a specific application domain, typically for reuse in multiple projects<br>Object-oriented domain analysis involves the identification, analysis, and specification of reusable capabilities within a specific application domain in terms of common objects, classes, subassemblies, and frameworks<br>伞活动涉及识别，分析和指定来自特定应用程序域的通用需求，通常可在多个项目中重用<br>面向对象的域分析涉及对特定应用程序域中的通用对象，类，子程序集和框架的可重用功能的标识，分析和规范</p></li><li><p>Which UML (unified modeling language) diagrams are useful in scenario-based modeling?<br>哪种UML（统一建模语言）图在基于场景的建模中有用？<br>Answer (Section 9.2):</p></li></ol><ul><li>use-case diagrams,</li><li>activitiy diagrams,</li><li>swimlane diagrams</li><li>用例图,</li><li>活动图,</li><li>泳道图</li></ul><ol start="3"><li><p>What questions should be asked to help refine a preliminary use case?.<br>应该问什么问题以帮助完善初步用例？<br>Answer (Section 9.2.2):<br>Can an actor take some other action at this point?<br>Is it possible that the actor will encounter some error condition at this point?<br>Is it possible the actor will encounter some other behavior at this point?<br>演员现在可以采取其他措施吗？<br>演员此时是否可能会遇到一些错误情况？<br>演员此时是否可能会遇到其他行为？</p></li><li><p>List the types of models that might be used in requirements modeling and explain the role of each type of model<br>列出需求建模中可能使用的模型类型，并解释每种模型的作用<br>Answer (Section 9.1):<br>Scenario-based (system from the user’s point of view)<br>Data (shows how data are transformed inside the system)<br>Class-oriented (defines objects, attributes, and relationships)<br>Flow-oriented (shows how data are transformed inside the system)<br>Behavioral (show the impact of events on the system states)<br>基于场景（从用户角度来看系统）<br>数据（显示数据如何在系统内部转换）<br>面向类（定义对象，属性和关系）<br>面向流（显示如何在系统内部转换数据）<br>行为的（显示事件对系统状态的影响）</p></li></ol><h2 id="CHAPTER-10-Requirements-Modeling-Class-Based-Methods-需求建模：基于类的方法"><a href="#CHAPTER-10-Requirements-Modeling-Class-Based-Methods-需求建模：基于类的方法" class="headerlink" title="CHAPTER 10 Requirements Modeling: Class-Based Methods 需求建模：基于类的方法"></a><span id="10">CHAPTER 10 Requirements Modeling: Class-Based Methods 需求建模：基于类的方法</span></h2><ol><li>What types of nouns resulting from a grammatical parse should be considered as potential analysis classes?<br>语法分析产生的哪些类型的名词应被视为潜在的分析类？<br>Answer (Section 10.1):</li></ol><ul><li>External entities (systems, devices, people)</li><li>Things (e.g. reports, displays, letters, signals)</li><li>Events occurring during system operation</li><li>Roles (e.g. manager, engineer, salesperson)</li><li>Organizational units (e.g. division, group, team)</li><li>Places</li><li>Structures (e.g. sensors, vehicles, computers)</li><li>外部实体（系统，设备，人员</li><li>事物（例如报告，显示，信件，信号</li><li>系统运行期间发生的事件</li><li>角色（例如经理，工程师，销售员</li><li>组织单位（例如部门，小组，团队</li><li>地方</li><li>结构（例如传感器，车辆，计算机</li></ul><ol start="2"><li><p>Describe the roles of the three sections of CRC (class responsibility collaborator) cards?<br>请描述CRC（类责任协作者）卡的三个部分的作用？<br>Answer (Section 10.4):<br>Class name identifies the data object uniquely.<br>Responsibilities are the attributes and operations for the class.<br>Collaborators are those classes required to provide a class with information needed to complete a responsibility.</p></li><li><p>List three types of classes that may be present in the analysis model.<br>列出分析模型中可能存在的三种类型的类。<br>Answer (Section 10.4):<br>Entity classes, Boundary classes, Controller classes<br>实体类，边界类，控制器类</p></li><li><p>List the characteristics that should be considered when considering potential classes for inclusion in an analysis model.<br>列出在考虑将潜在类包括在分析模型中时应考虑的特征。<br>Answer (Section 10.1):</p></li></ol><ul><li>Contains information that should be retained</li><li>Provides needed services</li><li>Contains multiple attributes</li><li>Has common set of attributes that apply to all class instances</li><li>Has common set of operations that apply to all object instances<br>Represents external entity that produces or consumes information</li><li>包含应保留的信息</li><li>提供所需的服务</li><li>包含多个属性</li><li>具有适用于所有类实例的通用属性集</li><li>具有适用于所有对象实例的通用操作集</li><li>代表产生或消费信息的外部实体</li></ul><h2 id="CHAPTER-11-Requirements-Modeling-Behavior-Patterns-and-Web-Mobile-Apps-需求建模：行为和模式"><a href="#CHAPTER-11-Requirements-Modeling-Behavior-Patterns-and-Web-Mobile-Apps-需求建模：行为和模式" class="headerlink" title="CHAPTER 11 Requirements Modeling: Behavior, Patterns, and Web/Mobile Apps 需求建模：行为和模式"></a><span id="11">CHAPTER 11 Requirements Modeling: Behavior, Patterns, and Web/Mobile Apps 需求建模：行为和模式</span></h2><ol><li><p>What are the steps needed to build a behavioral model?<br>建立行为模型需要采取什么步骤？<br>Answer (Section 11.1)<br>Evaluate the use-cases to understand the interaction sequence within the system.<br>Identify events that drive the interaction sequence and how the events relate to specific objects.<br>Create an event trace for each use-case.<br>Build a state transition diagram for the system.<br>Review the object-behavior model to verify accuracy and consistency.<br>评估用例以了解系统内的交互顺序。<br>确定驱动交互顺序的事件以及事件与特定对象的关系。<br>为每个用例创建一个事件跟踪。<br>为系统构建状态转换图。<br>查看对象行为模型以验证准确性和一致性。</p></li><li><p>How should analysis patterns be documented once they are discovered?<br>发现分析模式后应如何记录？<br>Answer (Section 11.4)<br>The pattern documentation contains a description of the problem, the prescribed solution, assumptions, constraints, motivations, driving forces, advantages, disadvantages, and references to know applications.<br>模式文档包含问题的描述，指定的解决方案，假设，约束，动机，驱动力，优点，缺点以及对已知应用程序的引用。</p></li><li><p>Describe the contents of the WebApp content, functional, interaction, and configuration models.<br>描述WebApp内容，功能，交互和配置模型的内容。<br>Answer (Section 11.5.3):</p></li></ol><ul><li>Content model - structural elements that represent WebApp content requirements (UML class diagrams)</li><li>Functional model - user observable behavior delivered to end-users and operations contained in analysis classes to implement class behaviors (UML activity diagrams)</li><li>Interaction model – indicates how users make use of the WebApp content and functionality (use-cases, UML sequence diagrams, state diagrams, user interface prototype)</li><li>Configuration model - may be a list of server-side and client-side attributes required for the WebApp (UML deployment diagrams)</li><li>内容模型-表示WebApp内容需求的结构元素（UML类图）</li><li>功能模型-交付给最终用户的用户可观察到的行为以及分析类中包含的用于实现类行为的操作（UML活动图）</li><li>交互模型–指示用户如何利用WebApp的内容和功能（用例，UML序列图，状态图，用户界面原型）</li><li>配置模型-可能是WebApp所需的服务器端和客户端属性的列表（UML部署图）</li></ul><ol start="4"><li>Under what circumstances should requirements modeling be utilized for Web or mobile apps?<br>在什么情况下应将需求建模用于Web或移动应用程序？<br>Answer (Section 11.5)</li></ol><ul><li>Large or complex app to be built</li><li>Large number of stakeholders</li><li>Large number developers onapp team</li><li>Development team members have not worked together before</li><li>App success will have strong bearing on success of company</li><li>大型或复杂的应用程序将被构建</li><li>大量利益相关者</li><li>大批开发人员onapp团队</li><li>开发团队成员之前从未合作过</li><li>应用程序的成功与公司的成功息息相关</li></ul><h2 id="CHAPTER-12-Design-Concepts-设计概念"><a href="#CHAPTER-12-Design-Concepts-设计概念" class="headerlink" title="CHAPTER 12 Design Concepts 设计概念"></a><span id="12">CHAPTER 12 Design Concepts 设计概念</span></h2><ol><li>List three characteristics that can serve as a guide to evaluate design quality.<br>列出三个可以作为评估设计质量指南的特征。<br>Answer (Section 12.2.1):<br>Design implements all explicit requirements from the analysis model, as well as accommodating implicit customer requirements.<br>Design must be understandable to the people who generate the code to implement design, those who test it, and those who support it.<br>Design must provide a complete picture of the software, addressing the data, functional, and behavioral domains from an implementation perspective.<br>设计实现分析模型中的所有显式需求，并适应隐性客户需求。<br>设计对于生成实现设计的代码的人员，测试它的人员以及支持它的人员必须是可以理解的。<br>设计必须提供软件的完整图片，从实现的角度解决数据，功能和行为领域。</li></ol><ol start="2"><li><p>Explain how effective modular design is achieved through functional independence of the individual modules?<br>解释如何通过各个模块的功能独立性来实现有效的模块化设计？<br>Answer (Section 12.3.5):<br>Functional independence of modules is achieved by making modules single-minded (high cohesion) and preventing excessive interaction (low coupling) with other modules or system elements. Independent modules are easier to develop, maintain, and test, because the impact of side effects is reduced (as is the propagation of errors). This also makes it easier to perform parallel implementation of modules.<br>通过使模块专一（高凝聚力）并防止与其他模块或系统元素的过度交互（低耦合）来实现模块的功能独立性。独立的模块更容易开发，维护和测试，因为减少了副作用的影响（错误的传播也是如此）。这也使得更容易执行模块的并行实现。</p></li><li><p>Describe the principle of information hiding as it applies to software design.<br>描述适用于软件设计的信息隐藏原理。<br>Answer (Section 12.3.6):<br>The principle of information hiding implies that modules only share information with each other on a “need to know” basis to achieve some specific software function. Hiding enforces the procedural constraints to both the module procedural detail and any data structures local to the module.<br>信息隐藏的原理意味着模块仅在“需要知道”的基础上彼此共享信息才能实现某些特定的软件功能。隐藏对模块过程详细信息和模块本地的任何数据结构都施加了过程约束。</p></li><li><p>List the four design models required for a complete specification of a software design and the role of each.<br>列出完整设计软件设计所需的四个设计模型以及每个模型的作用。<br>Answer (Section 12.4):<br>Data design – high level model depicting user’s view of the data or information.<br>Architecture design – shows relationships and collaborations among specific analysis model software and hardware elements<br>Interface design – interface depicts a set of operations that describe the externally observable behavior of a class and provides access to its operations<br>Component-level design – describes the internal detail of each software component<br>Deployment-level design – indicates how software functionality and subsystems will be allocated in the physical computing environment that will support the software<br>数据设计–描述用户对数据或信息的看法的高级模型。<br>体系结构设计–显示特定分析模型软件和硬件元素之间的关系和协作<br>界面设计–界面描述了一组操作，这些操作描述了一个类的外部可观察行为，并提供了对其操作的访问<br>组件级设计–描述每个软件组件的内部细节<br>部署级设计–指示如何在支持软件的物理计算环境中分配软件功能和子系统</p></li></ol><h2 id="CHAPTER-13-Architectural-Design-体系结构设计"><a href="#CHAPTER-13-Architectural-Design-体系结构设计" class="headerlink" title="CHAPTER 13 Architectural Design 体系结构设计"></a><span id="13">CHAPTER 13 Architectural Design 体系结构设计</span></h2><ol><li>What are the elements that make up a software architectural style?<br>构成软件架构样式的元素是什么？<br>Answer (Section 13.3):</li></ol><ul><li>Set of components that perform required system functions.</li><li>Set of connectors allowing communications among the components.</li><li>Constraints describing how the components maybe integrated to form a system.</li><li>Semantic models that enable the designer to understand the overall system properties by analyzing the known properties of its components.</li><li>执行所需系统功能的组件集。</li><li>一组连接器，允许组件之间进行通信。</li><li>约束条件，描述了如何集成组件以形成系统。</li><li>语义模型使设计人员能够通过分析其组件的已知属性来了解整个系统的属性。</li></ul><ol start="2"><li><p>What is an archetype?<br>什么是原型？<br>Answer (Section 13.6.2):<br>An archetype is a class or pattern that represents a core abstraction that is critical to the design of an architecture for the target system.<br>原型是代表核心抽象的类或模式，该抽象对目标系统的体系结构设计至关重要。</p></li><li><p>Explain the key differences between thin client architectures and a rich client architecture.<br>解释瘦客户端架构和富客户端架构之间的主要区别.<br>Answer (Section 13.6.6):<br>For mobile devices or web apps using thin client only the user interface layer is implemented on the device, A rich client typical allocates the user interface layer, business layer, and often the data layer too on the user’s device.<br>对于使用瘦客户端的移动设备或Web应用程序，仅在设备上实现了用户界面层。富客户端通常会在用户设备上分配用户界面层，业务层，通常还会分配数据层。</p></li><li><p>Describe the types of dependencies that can exist in an architectural design.<br>描述体系结构设计中可能存在的依赖项类型。<br>Answer (Section 13.7.2):<br>Sharing dependencies - represent the dependence relationships among consumers whose use the same source or producers who have the same consumers.<br>Flow dependencies - represent dependence relationships between producers and consumers of resources<br>Constrained dependencies - represent constraints on the relative flow of control among a set of activities<br>共享依赖关系-表示使用相同来源的消费者或使用相同消费者的生产者之间的依赖关系。<br>流依赖性-表示资源生产者和消费者之间的依赖关系<br>约束依赖性-表示一组活动之间相对控制流的约束</p></li></ol><h2 id="CHAPTER-14-Component-Level-Design-设计基于类的构建"><a href="#CHAPTER-14-Component-Level-Design-设计基于类的构建" class="headerlink" title="CHAPTER 14 Component-Level Design 设计基于类的构建"></a><span id="14">CHAPTER 14 Component-Level Design 设计基于类的构建</span></h2><ol><li><p>How does the object-oriented view of component-level design differ from the traditional view?<br>组件级设计的面向对象视图与传统视图有何不同？<br>Answer (Section 14.1.1 and 14.1.2):<br>The object-oriented view focuses on the elaboration of design classes that come from both the problem and infrastructure domains. Classes are elaborated by specifying messaging details, identifying interfaces, defining attribute data structures, and describing process flow for operations. In the traditional view, three of components are refined: control modules, domain modules, and infrastructure modules. This requires representations to be created for data structures, interfaces, and algorithms for each program module in enough detail to generate programming language source code.<br>面向对象的观点侧重于阐述来自问题领域和基础架构领域的设计类。通过指定消息传递详细信息，标识接口，定义属性数据结构以及描述操作的流程来详细说明类。在传统视图中，对三个组件进行了改进：控制模块，域模块和基础结构模块。这要求为每个程序模块的数据结构，接口和算法创建足够详细的表示，以生成编程语言源代码。</p></li><li><p>Describe the differences between the software engineering terms coupling and cohesion?<br>描述软件工程术语耦合和内聚之间的区别？<br>Answer (Section 14.2.3 and 14.2.4):<br>Cohesion implies that a component or class encapsulates only the attributes and operations closely related to one another and to the class itself. Coupling is a qualitative measure of the degree to which components are connected to one another.<br>内聚意味着组件或类仅封装彼此之间以及与类本身紧密相关的属性和操作。耦合是组件相互连接程度的定性度量。</p></li><li><p>Describe the component-level design for WebApps.<br>描述WebApp的组件级设计Answer (Section 14.4):<br>Component-level design incorporates elements of both content design and functional design. Content design at the component level focuses on content objects and then manner in which they may be packaged for presentation to a WebApp end-user. A functional architecture that describes the key functional components in the WebApp and how these components interact with each other is also created.<br>组件级设计结合了内容设计和功能设计的元素。组件级别的内容设计侧重于内容对象，然后着重于将它们打包以呈现给WebApp最终用户的方式。还创建了一个功能架构，该功能架构描述了WebApp中的关键功能组件以及这些组件之间的交互方式。</p></li><li><p>What is the intent of domain engineering in CBSE?<br>CBSE中域工程的目的是什么？<br>Answer (Section 14.7.1):<br>The intent of domain engineering is to identify, construct, catalog, and disseminate a set of software components that have applicability to existing and future software products.<br>领域工程的目的是识别，构造，分类和分发一组适用于现有和未来软件产品的软件组件</p></li><li><p>What are the steps used to complete the component-level design for a software development project?<br>完成软件开发项目的组件级设计所使用的步骤是什么？<br>Answer (Chapter 14.3):</p></li></ol><ul><li>Identify all design classes that correspond to the problem domain.</li><li>Identify all design classes that correspond to the infrastructure domain.</li><li>Elaborate all design classes that are not acquired as reusable components.</li><li>Identify persistent data sources (databases and files) and identify the classes required to manage them.</li><li>Develop and elaborate behavioral representations for each class or component.</li><li>Elaborate deployment diagrams to provide additional implementation detail.</li><li>Factor every component-level diagram representation and consider alternatives.</li><li>标识与问题域相对应的所有设计类。</li><li>标识与基础结构域相对应的所有设计类。</li><li>详细说明所有不作为可重用组件而获得的设计类。</li><li>标识持久性数据源（数据库和文件），并标识管理它们所需的类。</li><li>为每个类或组件开发并阐述行为表示。</li><li>详细的部署图提供了更多的实现细节。</li><li>分解每个组件级图的表示形式并考虑替代方案。</li></ul><h2 id="CHAPTER-15-User-Interface-Design-用户界面设计"><a href="#CHAPTER-15-User-Interface-Design-用户界面设计" class="headerlink" title="CHAPTER 15 User Interface Design 用户界面设计"></a><span id="15">CHAPTER 15 User Interface Design 用户界面设计</span></h2><ol><li>List three principles that should be applied when building any user interface.<br>列出构建任何用户界面时应应用的三个原则。<br>Answer (Section 15.1):</li></ol><ul><li>Place user in control.</li><li>Reduce user’s memory load.</li><li>Make the interface consistent.</li><li>将用户置于控制之下。</li><li>减少用户的内存负载。</li><li>使接口一致。</li></ul><ol start="2"><li>What framework activities are completed when following an evolutionary (or spiral) user interface development process?<br>在遵循演化（或螺旋式）用户界面开发过程时，完成哪些框架活动？<br>Answer (Section 15.2.2):</li></ol><ul><li>User, task, and environmental analysis</li><li>Interface design</li><li>Interface construction</li><li>Interface validation</li><li>用户，任务和环境分析</li><li>界面设计</li><li>接口构造</li><li>接口验证</li></ul><ol start="3"><li>List four interface design issues present in the development of most user interfaces.<br>列出大多数用户界面开发中存在的四个界面设计问题。<br>Answer (Section 15.4.3):</li></ol><ul><li>System response time</li><li>User help facilities</li><li>Error information handling</li><li>Menu and command labeling</li><li>Application accessibility</li><li>Internationalization</li><li>系统响应时间</li><li>用户帮助设施</li><li>错误信息处理</li><li>菜单和命令标签</li><li>应用程序可访问性</li><li>国际化</li></ul><ol start="4"><li>What are the primary design objectives of a WebApp interface?<br>WebApp界面的主要设计目标是什么？<br>Answer (Section 15.5):<br>The WebApp interface should be design a WebApp interface so it answers three primary questions for the end-user:</li></ol><ul><li>Where am I?”</li><li>What can I do now?</li><li>Where have I been, where am I going?</li><li>我在哪里？</li><li>我现在能做什么？</li><li>我去过哪里，我要去哪里？</li></ul><ol start="5"><li>What elements of a user interface design can be evaluated without building a working computer prototype?<br>无需构建有效的计算机原型就可以评估用户界面设计的哪些元素？<br>Answer (Section 15.6):<br>The length and complexity of the interface specification (provides insight into learning effort required by user).<br>The number of user tasks specified and the number of user actions required to complete each (provide estimates of system efficiency). Number of tasks, actions, and states in the design model (imply the memory load imposed on the user).<br>Interface style, help facilities, and error handling protocol provide a general indication of complexity of the interface and its acceptance by the users.<br>接口规范的长度和复杂性（可洞悉用户所需的学习努力）。<br>指定的用户任务数和完成每个任务所需的用户操作数（提供系统效率的估计值）。设计模型中的任务，动作和状态数（暗指施加给用户的内存负载）。<br>界面样式，帮助工具和错误处理协议提供了界面复杂性及其被用户接受的一般指示。</li></ol>]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化程序设计1-6章复习</title>
    <url>/2019/12/12/%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A11-6%E7%AB%A0%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<blockquote><p>可视化程序设计1-6章问答题<br>基于 <em>Software Engineering A PRACTITIONER’S APPROACH 8th</em> <em>软件工程：实践者的研究方法</em></p></blockquote><hr><ul><li><strong>PART 0 序</strong></li></ul><ol><li><a href="#1">CH1 软件的本质</a></li><li><a href="#2">CH2 软件工程</a><br>&nbsp;</li></ol><ul><li><strong>PART 1 软件过程 THE SOFTWARE PROCESS</strong></li></ul><ol><li><a href="#4">CH3 软件过程结构</a></li><li><a href="#5">CH4 过程模型</a></li><li><a href="#6">CH5 敏捷开发</a></li></ol><hr><a id="more"></a><h2 id="CHAPTER-1-THE-NATURE-OF-SOFTWARE-软件的本质"><a href="#CHAPTER-1-THE-NATURE-OF-SOFTWARE-软件的本质" class="headerlink" title="CHAPTER 1 THE NATURE OF SOFTWARE 软件的本质"></a><span id="1">CHAPTER 1 THE NATURE OF SOFTWARE 软件的本质</span></h2><ol><li>How does software differ from the artifacts produced by other engineering disciplines?<br>软件与其他工程学科产生的工件有何不同？<br>Answer (Section 1.1):<br>Software is both a product and a vehicle for delivering a product. As a product, software is an information transformer. As a vehicle for delivering a product, software serves as a basis for computer control, communication, and creation of other programs.<br>软件既是产品，又是交付产品的工具。作为产品，软件是一种信息转换器。作为交付产品的工具，软件是计算机控制，通信和创建其他程序的基础。</li></ol><ol start="2"><li><p>How do software characteristics differ from hardware characteristics?<br>软件特性与硬件特性有何不同？<br>Answer (Section 1.2):<br>Software is developed, not manufactured. Software does not wear out. Most software is custom built, not assembled out of components.<br>软件是开发的，不是制造的。软件不会磨损。大多数软件是定制构建的，而不是由组件组装而成的。</p></li><li><p>Explain what is wrong with the notion that computer software does not need to evolve over time.<br>解释一下计算机软件不需要随着时间的推移而发展的想法有什么问题。<br>Answer (Section1.1):<br>Computer software must be revised as errors are discovered and corrected. Software must be updated to accommodate changes in the computing environment. Many times a customer will request changes to add new functions to an existing product or to accommodate changes in the business environment. Sometimes an older system will need to be reengineered to provide benefits to the user in a modern context. The bottom line is that software that does not evolve will eventually become unusable.<br>发现并纠正错误后，必须对计算机软件进行修订。必须更新软件以适应计算环境的变化。客户常常会请求更改以将新功能添加到现有产品或适应业务环境中的更改。有时，将需要对旧系统进行重新设计，以在现代环境中为用户提供收益。最重要的是，不发展的软件最终将变得不可用。</p></li></ol><h2 id="CHAPTER-2-SOFTWARE-ENGINEERING-软件工程"><a href="#CHAPTER-2-SOFTWARE-ENGINEERING-软件工程" class="headerlink" title="CHAPTER 2 SOFTWARE ENGINEERING  软件工程"></a><span id="2">CHAPTER 2 SOFTWARE ENGINEERING 软件工程</span></h2><ol><li>List three areas in which process models may differ from one another.<br>列出过程模型（过程的适应性）可能彼此不同的三个领域。<br>Answer (Section 2.2):<ol><li>Overall flow and level of interdependencies among tasks</li><li>Degree to which work tasks are defined within each framework activity</li><li>Degree to which work products are identified and required</li><li>Manner in which quality assurance activities are applied</li><li>Manner in which project tracking and control activities are applied</li><li>Overall degree of detail and rigor of process description</li><li>Degree to which stakeholders are involved in the project</li><li>Level of autonomy given to project team</li><li>Degree to which team organization and roles are prescribed</li><li>任务之间的总体流程和相互依赖程度</li><li>每个框架活动中定义工作任务的程度</li><li>确定和要求工作产品的程度</li><li>实施质量保证活动的方式</li><li>应用项目跟踪和控制活动的方式</li><li>总体细节程度和过程描述的严格性</li><li>利益相关者参与项目的程度</li><li>给予项目团队的自主权</li><li>规定团队组织和角色的程度</li></ol></li></ol><ol start="2"><li>Describe how Polya’s problem solving principles describe the essence of engineering practice?<br>描述Polya的问题解决原理如何描述工程实践的本质？<br>Answer (Section 2.3):<br>· Understand the problem (communication and analysis)<br>· Plan a solution (modeling and design)<br>· Carry out the plan (code generation)<br>· Examine the result for accuracy (testing and quality assurance)</li></ol><p>· 了解问题（沟通和分析）<br>· 计划解决方案（建模和设计）<br>· 执行计划（代码生成）<br>· 检查结果的准确性（测试和质量保证）</p><ol start="3"><li>Describe the relationships among software engineering process, methods, and tools.<br>描述软件工程过程，方法和工具之间的关系。<br>Answer (Section2.1):<br>Software process defines the framework that must be established for effective delivery of software engineering technology, by providing a context by which the software engineering methods are applied. Software engineering methods provide the technical how-to’s for building software. Software engineering tools provide automated or semi-automated support for software engineering process and methods.<br>软件过程通过提供应用软件工程方法的上下文来定义为有效交付软件工程技术而必须建立的框架。软件工程方法提供了构建软件的技术指导。软件工程工具为软件工程过程和方法提供自动或半自动支持。</li></ol><hr><p><strong>PART ONE THE SOFTWARE PROCESS 软件过程</strong></p><h2 id="CHAPTER-3-SOFTWARE-PROCESS-STRUCTURE-软件过程结构"><a href="#CHAPTER-3-SOFTWARE-PROCESS-STRUCTURE-软件过程结构" class="headerlink" title="CHAPTER 3 SOFTWARE PROCESS STRUCTURE 软件过程结构"></a><span id="3">CHAPTER 3 SOFTWARE PROCESS STRUCTURE 软件过程结构</span></h2><ol><li><p>How are tasks, actions, and activities related to software process models? 任务，动作和活动与软件过程模型如何相关？<br>Answer (Section 3.1):<br>A software process is made up of activities. Each activity is defined by a set of engineering actions. Each activity is defined by a task set that indentifies the work items to be completed.<br>软件过程由活动组成。每个活动由一组工程动作定义。每个活动都由一个任务集定义，该任务集标识要完成的工作项。</p></li><li><p>How does software team choose the task set for a particular project? 软件团队如何选择特定项目的任务集？<br>Answer (Section 3.3):<br>The software chooses the task set based on the characteristics of the team, the project, and the problem to be solved.<br>该软件根据团队，项目和要解决的问题的特征来选择任务集。</p></li><li><p>How can process patterns assist a development team build software products efficiently? 流程模式如何帮助开发团队有效地构建软件产品？<br>Answer (Section 3.4):<br>Process patterns are proven solutions to commonly encountered development problems. If developers can recognize that that this is problem seen before they can use a previously known means of solving it, without have to take the time to invent a new solution.<br>流程模式是公认的解决常见开发问题的解决方案。如果开发人员可以认识到这是一个问题，那么他们可以使用以前已知的解决方法，而不必花费时间来发明新的解决方案。</p></li><li><p>Why it important for software processes to be agile? 为什么软件流程敏捷至关重要？<br>Answer (Chapter 3 Overview):<br>Software process provides the stability, control, and organization to an activity to prevent it from becoming chaotic. Yet, modern software processes must only demand the activities, controls, and work products that are appropriate for the team and product to be produced – to ensure that it can accommodate changes easily and deliver a high quality software product.<br>软件过程为活动提供稳定性，控制力和组织性，以防止其变得混乱。但是，现代软件过程必须只要求适合于要生产的团队和产品的活动，控制和工作产品，以确保它可以轻松地适应变更并交付高质量的软件产品。</p></li></ol><h2 id="CHAPTER-4-PROCESS-MODELS-过程模型"><a href="#CHAPTER-4-PROCESS-MODELS-过程模型" class="headerlink" title="CHAPTER 4 PROCESS MODELS 过程模型"></a><span id="4">CHAPTER 4 PROCESS MODELS 过程模型</span></h2><ol><li><p>Describe the phases of the prototyping model for software development?<br>描述软件开发原型模型的各个阶段？<br>Answer (Section 4.1.3):<br>Requirements are gathered by having the customer and developer meet and identify whatever objectives and requirements they can. Quick design follows, focusing on representation of the software that will be visible to the customer. A prototype is constructed by the developer and evaluated by the customer and used to refine the requirements. Iteration occurs and the prototype is tuned to satisfy the customer’s needs.<br>通过让客户和开发人员满足并确定他们可以达到的任何目标和要求来收集需求。随后进行快速设计，重点是对客户可见的软件表示形式。原型由开发人员构建并由客户评估，用于完善需求。进行迭代，并对原型进行调整以满足客户的需求。</p></li><li><p>What are the primary advantages of the component-based process model for software engineering?<br>基于组件的过程模型对软件工程的主要优势是什么？<br>Answer (Section 4.2.1):<br>Component-based process models promote software reuse and reusability and can result in: 70% reduction in development cycle times, 84% reduction in project costs, and 70% increase in productivity.<br>基于组件的过程模型可提高软件的重用性和可重用性，并可以导致：开发周期时间减少70％，项目成本减少84％，生产力提高70％。</p></li><li><p>Why has the Personal Software Process not been widely adopted by industry?<br>为什么个人软件过程没有被业界广泛采用？<br>Answer (Section 2.6.1):<br>PSP is intellectually challenging and demands a level of commitment (e.g. lengthy and costly training required) that is not always possible to obtain. In addition the required level of measurement is culturally hard for many software practitioners.<br>PSP在智力上具有挑战性，需要一定程度的承诺（例如，需要冗长而昂贵的培训），而这种承诺并非总是可以实现的。另外，对于许多软件从业人员而言，所需的度量水平在文化上是困难的。</p></li><li><p>Why are evolutionary models considered by many to be the best approach to software development in a modern context?<br>为什么许多人认为演化模型是现代环境下软件开发的最佳方法？<br>Answer (Section 4.1.3):<br>Because time lines for the development of modern software are getting shorter and shorter, customers are becoming more diverse (making the understanding of requirements even harder), and changes to requirements are becoming even more common (before delivery), we need a way to provide incremental or evolutionary delivery. The evolutionary process accommodates uncertainty better than most process models, allows the delivery of partial solutions in an orderly and planned manner, and most importantly, reflects what really happens when complex systems are built.<br>由于开发现代软件的时间表越来越短，客户变得越来越多样化（使对需求的理解更加困难），对需求的更改也变得越来越普遍（交付之前），我们需要一种方法来提供增量或渐进式投放。演化过程比大多数过程模型更好地适应不确定性，允许以有序和计划的方式交付部分解决方案，最重要的是，它反映了构建复杂系统时实际发生的情况。</p></li></ol><h2 id="CHAPTER-5-AGILE-DEVELOPMENT-敏捷开发"><a href="#CHAPTER-5-AGILE-DEVELOPMENT-敏捷开发" class="headerlink" title="CHAPTER 5 AGILE DEVELOPMENT 敏捷开发"></a><span id="5">CHAPTER 5 AGILE DEVELOPMENT 敏捷开发</span></h2><ol><li><p>List the key issues stressed by an agile philosophy of software engineering.<br>列出敏捷软件工程哲学所强调的关键问题。<br>Answer (Section 5.7):<br>The importance of self-organizing teams<br>Communication and collaboration between team members and customers<br>Recognition that change represents opportunity<br>Emphasis on rapid delivery of software that satisfies the customer</p></li><li><p>What are the tradeoffs proposes by the “Manifesto for Agile Software Development”?<br>“敏捷软件开发宣言”提出的权衡是什么？<br>Answer (Section 5.1):<br>Individuals and interactions valued over processes and tools<br>Working software valued over comprehensive documentation<br>Customer collaboration valued over contract negotiation<br>Responding to change valued over following a plan<br>重视流程和工具的个人和互动<br>工作软件胜过完整的文档<br>客户合作比合同谈判更有价值<br>响应按照计划而重视的变更</p></li><li><p>Describe the role of customers and end-users on an agile process team?<br>描述客户和最终用户在敏捷流程团队中的角色？<br>Answer (Section 5.4):<br>Customers and end-users participate as full collaborators on agile process teams. They are the source of information used to create use cases and provided needed information on the business value of proposed software feature and functionality. They also provide much needed feedback on operational prototypes during incremental delivery of software increments.<br>客户和最终用户将作为正式合作者参与敏捷流程团队。它们是用于创建用例的信息源，并提供了有关拟议软件 功能的商业价值的必要信息。在软件增量的增量交付期间，它们还提供了有关操作原型的急需的反馈。</p></li><li><p>Describe the three key assumptions regarding software projects that every agile software process must address.<br>描述关于每个敏捷软件过程都必须解决的软件项目的三个关键假设。<br>Answer (Section 5.3):<br>It is difficult to predict in advance which software requirements and customer priorities will change and which will not.<br>For many types of software design and construction must be interleaved, it is difficult to predict how much design is needed before construction can be used to prove the design.<br>Analysis, design, construction, and testing are not always predictable processes and this makes planning difficult.<br>很难预先预测哪些软件需求和客户优先级将发生变化，哪些不会发生变化。<br>对于许多类型的软件，必须交错进行设计和构造，因此很难预测在使用构造来证明设计之前需要多少设计。<br>分析，设计，构造和测试并非总是可预测的过程，这使计划变得困难。</p></li></ol><h2 id="CHAPTER-6-HUMAN-ASPECTS-OF-SOFTWARE-ENGINEERING-软件工程人员"><a href="#CHAPTER-6-HUMAN-ASPECTS-OF-SOFTWARE-ENGINEERING-软件工程人员" class="headerlink" title="CHAPTER 6 HUMAN ASPECTS OF SOFTWARE ENGINEERING 软件工程人员"></a><span id="6">CHAPTER 6 HUMAN ASPECTS OF SOFTWARE ENGINEERING 软件工程人员</span></h2><ol><li><p>List the key attributes of an effective software teams.<br>列出有效的软件团队的关键属性<br>Answer (Section 6.3):<br>Sense of purpose<br>Sense of involvement<br>Sense of trust<br>Sense of improvement<br>Diversity of team member skill sets<br>目的感<br>参与感<br>信任感<br>改善感<br>团队成员技能集的多样性</p></li><li><p>Describe the strengths and weaknesses of the random paradigm team structure?<br>请描述随机范式团队结构的优缺点？<br>Answer (Section 6.4):<br>The random paradigm depends on the initiative of individual team members. Good when innovation or technological breakthrough is needed. These teams struggle when orderly performance is required.<br>随机范式取决于团队成员的主动性。当需要创新或技术突破时很好。当需要有秩序的表现时，这些团队就会挣扎。</p></li><li><p>Describe the five values held by XP teams?<br>请描述XP团队所持有的五个价值观？<br>Answer (Section 6.5):<br>Communication – close informal verbal communication among team members and stakeholders and establishing meaning for metaphors as part of continuous feedback<br>Simplicity – design for immediate needs nor future needs<br>Feedback – derives from the implemented software, the customer, and other team members<br>Courage – the discipline to resist pressure to design for unspecified future requirements<br>Respect – among team members and stakeholders<br>交流–团队成员和利益相关者之间的非正式口头交流，并为隐喻建立意义，作为持续反馈的一部分<br>简便性–针对眼前需求或未来需求的设计<br>反馈–来自实施的软件，客户和其他团队成员<br>勇气–应对未指定未来需求的设计压力的纪律<br>尊重–团队成员和利益相关者之间</p></li><li><p>List environment characteristics that can be considered toxic to software teams.<br>列出对软件团队有害的环境特征。<br>Answer (Section 6.3):<br>Frenzied work atmosphere<br>High frustration that causes friction among team members<br>Fragmented or poorly coordinated software process<br>Unclear definition of roles on the software team<br>Continuous and repeated exposure to failure<br>Differing and incompatible team member human traits<br>疯狂的工作氛围<br>挫败感高，导致团队成员之间产生摩擦<br>零散的或缺乏协调的软件流程<br>软件团队中角色的定义不明确<br>持续不断地遭受失败<br>团队成员不同且不相容的人格特质</p></li></ol>]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
  </entry>
  <entry>
    <title>操作系统概念第2章 — 操作系统结构</title>
    <url>/2019/11/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%AC2%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote><p>操作系统概念第2章：操作系统结构 Operating System Structures<br>基于 <em>Operating System Concepts(9th)</em></p></blockquote><a id="more"></a><h2 id="操作系统服务"><a href="#操作系统服务" class="headerlink" title="操作系统服务"></a>操作系统服务</h2><ul><li>用户界面 User Interface<ul><li>命令行界面 Command-line Interface，CLI</li><li>Batch界面</li><li>图形用户界面 Graphical User Interface，GUI</li></ul></li><li>程序执行 Program Execution<ul><li>操作系统可以夹在程序到内存（memory）中并执行程序</li></ul></li><li>IO操作 I/O Operation</li><li>文件系统操作 File-system manipulation</li><li>通信 Communications</li><li>错误检测 Error detection</li></ul><ul><li>下述的服务不是为了帮助用户，而是为了使操作系统的效率更高<ul><li>资源分配 Resource Allocation</li><li>统计 Accounting</li><li>保护和安全 Protection and security</li></ul></li></ul>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>tags test page</title>
    <url>/2019/11/17/tags-test-page/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title>test page</title>
    <url>/2019/11/16/test-page/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>hide</tag>
        <tag>随便写写</tag>
      </tags>
  </entry>
</search>
